<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>insertBefore()</title>
</head>
<body>
    <div class="parent1">parent1</div>
    <div class="parent2">parent2
        <div class="child1">child1</div>
        <div class="child2">child2</div>
    </div>
    <script>
        // insertAfter的polyfill
        (function(ndp) {
            ndp.insertAfter = ndp.insertAfter || function(newNode, referenceNode) {
                if(arguments.length < 2){
                    throw(new TypeError('Failed to execute \'insertAfter\' on \'Node\': 2 arguments required, but only '+ arguments.length +' present.'));
                }
                if(typeof(newNode) === 'object' && newNode !== null && newNode.nodeType > 0){
                    if(referenceNode === null || referenceNode === undefined){
                        return this.insertBefore(newNode, referenceNode);
                    }
                    if(typeof(referenceNode) === 'object' && referenceNode.nodeType > 0){
                        return this.insertBefore(newNode, referenceNode.nextSibling);
                    }
                    throw(new TypeError('Failed to execute \'insertAfter\' on \'Node\': parameter 2 is not of type \'Node\'.'));
                }
                throw(new TypeError('Failed to execute \'insertAfter\' on \'Node\': parameter 1 is not of type \'Node\'.'));
            };
        })(Node.prototype);

        var parent1 = document.querySelector('.parent1');
        var parent2 = document.querySelector('.parent2');
        var child1 = document.querySelector('.child1');
        var child2 = document.querySelector('.child2');
        var newChild = document.createElement('div');
        newChild.appendChild(document.createTextNode('newChild'));

        // 可以打开单个注释看效果

        // 把newChild插入parent1的内容末尾，返回newChild
        // console.log(parent1.insertBefore(newChild,null));

        // 把newChild插入parent2的内容末尾，返回newChild
        // parent2.insertBefore(newChild,undefined);

        // 把newChild插入child1之前，返回newChild
        // parent2.insertBefore(newChild,child1);

        // 把newChild插入child1之后，返回newChild
        // parent2.insertBefore(newChild,child1.nextSibling);

        // 把child2插入child1之前，先剪切再插入，返回child2
        // console.log(parent2.insertBefore(child2,child1));

        // 把parent1插入child1之后，先剪切再插入，返回parent1
        // console.log(parent2.insertAfter(parent1,child1));
    </script>
</body>
</html>